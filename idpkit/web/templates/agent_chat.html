{% extends "base.html" %}
{% block title %}IDA - Intelligent Document Assistant{% endblock %}
{% block content %}
<div class="page-header">
    <h2><i class="fas fa-brain"></i> IDA — Intelligent Document Assistant</h2>
</div>
<div class="chat-container" x-data="agentChat()">
    <div class="chat-sidebar">
        <!-- Conversations -->
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
            <h4 style="margin:0">Conversations</h4>
            <button class="btn btn-sm btn-primary" @click="newConversation()" title="New chat" style="padding:2px 8px;font-size:0.75rem">
                <i class="fas fa-plus"></i>
            </button>
        </div>
        <div class="conv-list" style="max-height:200px;overflow-y:auto;margin-bottom:16px">
            <div x-show="conversations.length === 0" style="font-size:0.8rem;color:var(--text-muted)">No conversations yet</div>
            <template x-for="conv in conversations" :key="conv.id">
                <div class="conv-item" :class="{ active: currentConversationId === conv.id }"
                     @click="loadConversation(conv.id)">
                    <span class="conv-title" x-text="conv.title"></span>
                    <button class="conv-delete" @click.stop="deleteConversation(conv.id)" title="Delete">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </template>
        </div>

        <h4>Tags</h4>
        <div class="tag-selector" x-show="tags.length > 0">
            <template x-for="tag in tags" :key="tag.id">
                <label class="tag-check">
                    <input type="checkbox" :value="tag.id" x-model="selectedTags" @change="onTagToggle(tag.id, $event.target.checked)">
                    <span class="tag-dot" :style="'background:' + tag.color"></span>
                    <span x-text="tag.name"></span>
                    <span class="badge" x-text="tag.document_count || 0" style="font-size:0.7rem;padding:1px 6px"></span>
                </label>
            </template>
        </div>
        <div x-show="tags.length === 0" style="font-size:0.8rem;color:var(--text-muted);margin-bottom:12px">No tags yet</div>
        <h4 style="margin-top:16px">Documents</h4>
        <div class="doc-selector">
            <template x-for="doc in documents" :key="doc.id">
                <label class="doc-check">
                    <input type="checkbox" :value="doc.id" x-model="selectedDocs">
                    <span x-text="doc.filename"></span>
                    <span class="badge" x-text="doc.format"></span>
                </label>
            </template>
        </div>
    </div>
    <div class="chat-main">
        <div class="chat-messages" id="chatMessages">
            <div class="welcome-msg" x-show="messages.length === 0">
                <i class="fas fa-brain" style="color: #7c3aed"></i>
                <h3>IDA — Intelligent Document Assistant</h3>
                <p>I can analyze, summarize, translate, compare, and compose content from your documents. I have access to 13 Smart Tools, knowledge graph queries, report generation, batch processing, and multi-document composition.</p>
                <div class="suggestions">
                    <button @click="sendMessage('List my documents')" class="suggestion-btn">List my documents</button>
                    <button @click="sendMessage('Summarize a document')" class="suggestion-btn">Summarize a document</button>
                    <button @click="sendMessage('Extract entities from my documents')" class="suggestion-btn">Extract entities</button>
                    <button @click="sendMessage('What tools are available?')" class="suggestion-btn">Available tools</button>
                    <button @click="sendMessage('Generate a report from a document')" class="suggestion-btn">Generate report</button>
                    <button @click="sendMessage('Translate a document to Spanish')" class="suggestion-btn">Translate document</button>
                </div>
            </div>
            <template x-for="(msg, i) in messages" :key="i">
                <div class="chat-msg" :class="'msg-' + msg.role"
                     @click="msg.role === 'assistant' && msg.sources && msg.sources.length > 0 ? showSources(msg.sources) : null"
                     :style="msg.role === 'assistant' && msg.sources && msg.sources.length > 0 ? 'cursor:pointer' : ''">
                    <div class="msg-avatar" :style="msg.role === 'assistant' ? 'background: linear-gradient(135deg, #7c3aed, #4f46e5); color: #fff' : ''">
                        <i :class="msg.role === 'user' ? 'fas fa-user' : msg.role === 'tool' ? 'fas fa-wrench' : 'fas fa-brain'"></i>
                    </div>
                    <div class="msg-content">
                        <div class="msg-header">
                            <span x-text="msg.role === 'user' ? 'You' : msg.role === 'tool' ? 'Tool: ' + (msg.tool_name || '') : 'IDA'"></span>
                            <span class="sources-badge" x-show="msg.sources && msg.sources.length > 0"
                                  x-text="'(' + (msg.sources ? msg.sources.length : 0) + ' sources)'"></span>
                        </div>
                        <div class="msg-body"
                             x-html="msg.role === 'assistant' ? renderMarkdown(msg.content) : msg.role === 'tool' ? '<pre>' + msg.content.replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</pre>' : msg.content.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/\n/g,'<br>')"
                             x-effect="if (msg.role === 'assistant' && typeof renderMathInElement !== 'undefined') { $nextTick(() => renderMathInElement($el, {delimiters: [{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false},{left: '\\\\(', right: '\\\\)', display: false},{left: '\\\\[', right: '\\\\]', display: true}]})) }">
                        </div>
                    </div>
                </div>
            </template>
            <div x-show="loading" class="chat-msg msg-assistant">
                <div class="msg-avatar" style="background: linear-gradient(135deg, #7c3aed, #4f46e5); color: #fff"><i class="fas fa-brain"></i></div>
                <div class="msg-content"><div class="typing-indicator"><span></span><span></span><span></span></div></div>
            </div>
        </div>
        <div class="chat-input-area">
            <div class="chat-upload-tags" x-show="uploadFiles.length > 0">
                <template x-for="(uf, idx) in uploadFiles" :key="idx">
                    <span class="chat-upload-tag" :class="uf.status">
                        <i :class="uf.status === 'ready' ? 'fas fa-check-circle' : uf.status === 'failed' ? 'fas fa-times-circle' : 'fas fa-spinner'"></i>
                        <span class="tag-name" x-text="uf.filename"></span>
                    </span>
                </template>
            </div>
            <div class="chat-input">
                <input type="file" id="chatFileInput" multiple style="display:none" @change="handleChatUpload($event)">
                <button class="btn-upload" @click="$refs.chatFileBtn ? $refs.chatFileBtn.click() : document.getElementById('chatFileInput').click()" title="Upload files" :disabled="loading">
                    <i class="fas fa-paperclip"></i>
                </button>
                <input type="text" x-model="input" @keyup.enter="sendMessage()" placeholder="Ask IDA anything about your documents..." :disabled="loading">
                <button @click="sendMessage()" class="btn btn-primary" :disabled="loading || !input.trim()">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
    <!-- Sources Panel -->
    <div class="chat-sources-panel" x-show="currentSources.length > 0" x-cloak>
        <h4><i class="fas fa-quote-left"></i> Sources</h4>
        <template x-for="(src, si) in currentSources" :key="si">
            <a :href="'/documents/' + src.document_id" class="source-card" target="_blank">
                <div class="source-title" x-text="src.title || 'Untitled section'"></div>
                <div class="source-meta">
                    <span class="source-filename" x-text="src.filename"></span>
                    <span class="source-pages" x-show="src.start_page != null">
                        pp. <span x-text="src.start_page"></span><span x-show="src.end_page != null && src.end_page !== src.start_page">–<span x-text="src.end_page"></span></span>
                    </span>
                </div>
                <div class="source-summary" x-show="src.summary" x-text="src.summary"></div>
            </a>
        </template>
    </div>
</div>
<script>
function agentChat() {
    return {
        messages: [], input: '', loading: false, documents: [], selectedDocs: [],
        uploadFiles: [],
        tags: [], selectedTags: [],
        currentSources: [],
        conversations: [],
        currentConversationId: null,
        async init() {
            const [docRes, tagRes, convRes] = await Promise.all([
                fetch('/api/documents/?limit=100'),
                fetch('/api/tags/'),
                fetch('/api/agent/conversations')
            ]);
            if (docRes.ok) { const data = await docRes.json(); this.documents = data.items || data.documents || []; }
            if (tagRes.ok) { this.tags = await tagRes.json(); }
            if (convRes.ok) { this.conversations = await convRes.json(); }
        },
        async onTagToggle(tagId, checked) {
            try {
                const res = await fetch('/api/tags/' + tagId);
                if (!res.ok) return;
                const tag = await res.json();
                const docIds = (tag.documents || []).map(d => d.id);
                if (checked) {
                    for (const did of docIds) {
                        if (!this.selectedDocs.includes(did)) this.selectedDocs.push(did);
                    }
                } else {
                    const otherTagDocs = new Set();
                    for (const tid of this.selectedTags) {
                        if (tid === tagId) continue;
                        try {
                            const r = await fetch('/api/tags/' + tid);
                            if (r.ok) { const t = await r.json(); (t.documents || []).forEach(d => otherTagDocs.add(d.id)); }
                        } catch(e) {}
                    }
                    this.selectedDocs = this.selectedDocs.filter(did => !docIds.includes(did) || otherTagDocs.has(did));
                }
            } catch(e) {}
        },
        async handleChatUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            for (const file of files) {
                const entry = { file, docId: null, status: 'uploading', filename: file.name };
                this.uploadFiles.push(entry);
                try {
                    const form = new FormData();
                    form.append('file', file);
                    const upRes = await fetch('/api/documents/', { method: 'POST', body: form });
                    if (!upRes.ok) { entry.status = 'failed'; continue; }
                    const doc = await upRes.json();
                    entry.docId = doc.id;
                    entry.status = 'indexing';
                    this.documents.push(doc);
                    await fetch('/api/indexing/documents/' + doc.id + '/index', { method: 'POST', headers: {'Content-Type': 'application/json'} });
                    let attempts = 0;
                    const maxAttempts = 60;
                    while (attempts < maxAttempts) {
                        await new Promise(r => setTimeout(r, 2000));
                        const statusRes = await fetch('/api/indexing/documents/' + doc.id + '/index/status');
                        if (statusRes.ok) {
                            const statusData = await statusRes.json();
                            const st = statusData.status || statusData.index_status || '';
                            if (st === 'indexed' || st === 'completed') {
                                entry.status = 'ready';
                                if (!this.selectedDocs.includes(doc.id)) {
                                    this.selectedDocs.push(doc.id);
                                }
                                break;
                            } else if (st === 'failed') {
                                entry.status = 'failed';
                                break;
                            }
                        }
                        attempts++;
                    }
                    if (attempts >= maxAttempts && entry.status === 'indexing') {
                        entry.status = 'failed';
                    }
                } catch (e) {
                    entry.status = 'failed';
                }
            }
            event.target.value = '';
        },
        showSources(sources) {
            this.currentSources = sources || [];
        },
        async sendMessage(text) {
            const msg = text || this.input.trim();
            if (!msg) return;
            this.input = '';
            this.messages.push({ role: 'user', content: msg, sources: null });
            this.loading = true;
            this.scrollToBottom();

            // Auto-create conversation if none active
            if (!this.currentConversationId) {
                try {
                    const convRes = await fetch('/api/agent/conversations', {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ title: 'New conversation' })
                    });
                    if (convRes.ok) {
                        const conv = await convRes.json();
                        this.currentConversationId = conv.id;
                        this.conversations.unshift(conv);
                    }
                } catch(e) {}
            }

            try {
                const res = await fetch('/api/agent/chat', {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        message: msg,
                        conversation_id: this.currentConversationId,
                        document_ids: this.selectedDocs,
                        tag_ids: this.selectedTags
                    })
                });
                if (res.ok) {
                    const data = await res.json();
                    if (data.tool_calls) {
                        for (const tc of data.tool_calls) {
                            this.messages.push({ role: 'tool', content: JSON.stringify(tc.result, null, 2), tool_name: tc.name, sources: null });
                        }
                    }
                    const msgSources = (data.sources && data.sources.length > 0) ? data.sources : null;
                    this.messages.push({ role: 'assistant', content: data.response || data.detail || 'No response', sources: msgSources });
                    // Update sources panel to show latest
                    if (msgSources) {
                        this.currentSources = msgSources;
                    }
                    // Update conversation title in sidebar
                    if (this.currentConversationId) {
                        const ci = this.conversations.find(c => c.id === this.currentConversationId);
                        if (ci && ci.title === 'New conversation') {
                            ci.title = msg.length > 100 ? msg.substring(0, 100) : msg;
                        }
                    }
                } else {
                    this.messages.push({ role: 'assistant', content: 'Error: request failed', sources: null });
                }
            } catch(e) { this.messages.push({ role: 'assistant', content: 'Error: ' + e.message, sources: null }); }
            finally { this.loading = false; this.scrollToBottom(); }
        },
        newConversation() {
            this.currentConversationId = null;
            this.messages = [];
            this.currentSources = [];
        },
        async loadConversation(convId) {
            if (convId === this.currentConversationId) return;
            this.currentConversationId = convId;
            this.messages = [];
            this.currentSources = [];
            try {
                const res = await fetch('/api/agent/conversations/' + convId);
                if (res.ok) {
                    const data = await res.json();
                    for (const m of data.messages) {
                        this.messages.push({
                            role: m.role,
                            content: m.content || '',
                            tool_name: m.tool_name || null,
                            sources: m.sources || null
                        });
                    }
                    this.scrollToBottom();
                }
            } catch(e) {}
        },
        async deleteConversation(convId) {
            try {
                await fetch('/api/agent/conversations/' + convId, { method: 'DELETE' });
                this.conversations = this.conversations.filter(c => c.id !== convId);
                if (this.currentConversationId === convId) {
                    this.newConversation();
                }
            } catch(e) {}
        },
        scrollToBottom() {
            this.$nextTick(() => {
                const el = document.getElementById('chatMessages');
                if (el) el.scrollTop = el.scrollHeight;
            });
        }
    }
}
</script>
{% endblock %}
