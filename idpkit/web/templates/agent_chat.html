{% extends "base.html" %}
{% block title %}IDA - Intelligent Document Assistant{% endblock %}
{% block content %}
<div class="page-header">
    <h2><i class="fas fa-brain"></i> IDA — Intelligent Document Assistant</h2>
</div>
<div class="chat-container" x-data="agentChat()">
    <div class="chat-sidebar">
        <h4>Tags</h4>
        <div class="tag-selector" x-show="tags.length > 0">
            <template x-for="tag in tags" :key="tag.id">
                <label class="tag-check">
                    <input type="checkbox" :value="tag.id" x-model="selectedTags" @change="onTagToggle(tag.id, $event.target.checked)">
                    <span class="tag-dot" :style="'background:' + tag.color"></span>
                    <span x-text="tag.name"></span>
                    <span class="badge" x-text="tag.document_count || 0" style="font-size:0.7rem;padding:1px 6px"></span>
                </label>
            </template>
        </div>
        <div x-show="tags.length === 0" style="font-size:0.8rem;color:var(--text-muted);margin-bottom:12px">No tags yet</div>
        <h4 style="margin-top:16px">Documents</h4>
        <div class="doc-selector">
            <template x-for="doc in documents" :key="doc.id">
                <label class="doc-check">
                    <input type="checkbox" :value="doc.id" x-model="selectedDocs">
                    <span x-text="doc.filename"></span>
                    <span class="badge" x-text="doc.format"></span>
                </label>
            </template>
        </div>
    </div>
    <div class="chat-main">
        <div class="chat-messages" id="chatMessages">
            <div class="welcome-msg" x-show="messages.length === 0">
                <i class="fas fa-brain" style="color: #7c3aed"></i>
                <h3>IDA — Intelligent Document Assistant</h3>
                <p>I can analyze, summarize, translate, compare, and compose content from your documents. I have access to 13 Smart Tools, knowledge graph queries, report generation, batch processing, and multi-document composition.</p>
                <div class="suggestions">
                    <button @click="sendMessage('List my documents')" class="suggestion-btn">List my documents</button>
                    <button @click="sendMessage('Summarize a document')" class="suggestion-btn">Summarize a document</button>
                    <button @click="sendMessage('Extract entities from my documents')" class="suggestion-btn">Extract entities</button>
                    <button @click="sendMessage('What tools are available?')" class="suggestion-btn">Available tools</button>
                    <button @click="sendMessage('Generate a report from a document')" class="suggestion-btn">Generate report</button>
                    <button @click="sendMessage('Translate a document to Spanish')" class="suggestion-btn">Translate document</button>
                </div>
            </div>
            <template x-for="(msg, i) in messages" :key="i">
                <div class="chat-msg" :class="'msg-' + msg.role">
                    <div class="msg-avatar" :style="msg.role === 'assistant' ? 'background: linear-gradient(135deg, #7c3aed, #4f46e5); color: #fff' : ''">
                        <i :class="msg.role === 'user' ? 'fas fa-user' : msg.role === 'tool' ? 'fas fa-wrench' : 'fas fa-brain'"></i>
                    </div>
                    <div class="msg-content">
                        <div class="msg-header" x-text="msg.role === 'user' ? 'You' : msg.role === 'tool' ? 'Tool: ' + (msg.tool_name || '') : 'IDA'"></div>
                        <div class="msg-body"
                             x-html="msg.role === 'assistant' ? renderMarkdown(msg.content) : msg.role === 'tool' ? '<pre>' + msg.content.replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</pre>' : msg.content.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/\n/g,'<br>')"
                             x-effect="if (msg.role === 'assistant' && typeof renderMathInElement !== 'undefined') { $nextTick(() => renderMathInElement($el, {delimiters: [{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false},{left: '\\\\(', right: '\\\\)', display: false},{left: '\\\\[', right: '\\\\]', display: true}]})) }">
                        </div>
                    </div>
                </div>
            </template>
            <div x-show="loading" class="chat-msg msg-assistant">
                <div class="msg-avatar" style="background: linear-gradient(135deg, #7c3aed, #4f46e5); color: #fff"><i class="fas fa-brain"></i></div>
                <div class="msg-content"><div class="typing-indicator"><span></span><span></span><span></span></div></div>
            </div>
        </div>
        <div class="chat-input-area">
            <div class="chat-upload-tags" x-show="uploadFiles.length > 0">
                <template x-for="(uf, idx) in uploadFiles" :key="idx">
                    <span class="chat-upload-tag" :class="uf.status">
                        <i :class="uf.status === 'ready' ? 'fas fa-check-circle' : uf.status === 'failed' ? 'fas fa-times-circle' : 'fas fa-spinner'"></i>
                        <span class="tag-name" x-text="uf.filename"></span>
                    </span>
                </template>
            </div>
            <div class="chat-input">
                <input type="file" id="chatFileInput" multiple style="display:none" @change="handleChatUpload($event)">
                <button class="btn-upload" @click="$refs.chatFileBtn ? $refs.chatFileBtn.click() : document.getElementById('chatFileInput').click()" title="Upload files" :disabled="loading">
                    <i class="fas fa-paperclip"></i>
                </button>
                <input type="text" x-model="input" @keyup.enter="sendMessage()" placeholder="Ask IDA anything about your documents..." :disabled="loading">
                <button @click="sendMessage()" class="btn btn-primary" :disabled="loading || !input.trim()">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
    <!-- Sources Panel -->
    <div class="chat-sources-panel" x-show="currentSources.length > 0" x-cloak>
        <h4><i class="fas fa-quote-left"></i> Sources</h4>
        <template x-for="(src, si) in currentSources" :key="si">
            <a :href="'/documents/' + src.document_id" class="source-card" target="_blank">
                <div class="source-title" x-text="src.title || 'Untitled section'"></div>
                <div class="source-meta">
                    <span class="source-filename" x-text="src.filename"></span>
                    <span class="source-pages" x-show="src.start_page != null">
                        pp. <span x-text="src.start_page"></span><span x-show="src.end_page != null && src.end_page !== src.start_page">–<span x-text="src.end_page"></span></span>
                    </span>
                </div>
                <div class="source-summary" x-show="src.summary" x-text="src.summary"></div>
            </a>
        </template>
    </div>
</div>
<script>
function agentChat() {
    return {
        messages: [], input: '', loading: false, documents: [], selectedDocs: [],
        uploadFiles: [],
        tags: [], selectedTags: [],
        currentSources: [],
        async init() {
            const [docRes, tagRes] = await Promise.all([
                fetch('/api/documents/?limit=100'),
                fetch('/api/tags/')
            ]);
            if (docRes.ok) { const data = await docRes.json(); this.documents = data.items || data.documents || []; }
            if (tagRes.ok) { this.tags = await tagRes.json(); }
        },
        async onTagToggle(tagId, checked) {
            // When a tag is checked/unchecked, auto-select/deselect its documents
            try {
                const res = await fetch('/api/tags/' + tagId);
                if (!res.ok) return;
                const tag = await res.json();
                const docIds = (tag.documents || []).map(d => d.id);
                if (checked) {
                    for (const did of docIds) {
                        if (!this.selectedDocs.includes(did)) this.selectedDocs.push(did);
                    }
                } else {
                    // Only remove docs that aren't in any other selected tag
                    const otherTagDocs = new Set();
                    for (const tid of this.selectedTags) {
                        if (tid === tagId) continue;
                        try {
                            const r = await fetch('/api/tags/' + tid);
                            if (r.ok) { const t = await r.json(); (t.documents || []).forEach(d => otherTagDocs.add(d.id)); }
                        } catch(e) {}
                    }
                    this.selectedDocs = this.selectedDocs.filter(did => !docIds.includes(did) || otherTagDocs.has(did));
                }
            } catch(e) {}
        },
        async handleChatUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            for (const file of files) {
                const entry = { file, docId: null, status: 'uploading', filename: file.name };
                this.uploadFiles.push(entry);
                try {
                    // Upload
                    const form = new FormData();
                    form.append('file', file);
                    const upRes = await fetch('/api/documents/', { method: 'POST', body: form });
                    if (!upRes.ok) { entry.status = 'failed'; continue; }
                    const doc = await upRes.json();
                    entry.docId = doc.id;
                    entry.status = 'indexing';
                    // Add to sidebar documents list
                    this.documents.push(doc);
                    // Trigger indexing
                    await fetch('/api/indexing/documents/' + doc.id + '/index', { method: 'POST', headers: {'Content-Type': 'application/json'} });
                    // Poll for index completion
                    let attempts = 0;
                    const maxAttempts = 60;
                    while (attempts < maxAttempts) {
                        await new Promise(r => setTimeout(r, 2000));
                        const statusRes = await fetch('/api/indexing/documents/' + doc.id + '/index/status');
                        if (statusRes.ok) {
                            const statusData = await statusRes.json();
                            const st = statusData.status || statusData.index_status || '';
                            if (st === 'indexed' || st === 'completed') {
                                entry.status = 'ready';
                                if (!this.selectedDocs.includes(doc.id)) {
                                    this.selectedDocs.push(doc.id);
                                }
                                break;
                            } else if (st === 'failed') {
                                entry.status = 'failed';
                                break;
                            }
                        }
                        attempts++;
                    }
                    if (attempts >= maxAttempts && entry.status === 'indexing') {
                        entry.status = 'failed';
                    }
                } catch (e) {
                    entry.status = 'failed';
                }
            }
            // Reset file input so the same file can be re-selected
            event.target.value = '';
        },
        async sendMessage(text) {
            const msg = text || this.input.trim();
            if (!msg) return;
            this.input = '';
            this.messages.push({ role: 'user', content: msg });
            this.loading = true;
            this.currentSources = [];
            this.scrollToBottom();
            try {
                const res = await fetch('/api/agent/chat', {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ message: msg, document_ids: this.selectedDocs, tag_ids: this.selectedTags })
                });
                if (res.ok) {
                    const data = await res.json();
                    if (data.tool_calls) {
                        for (const tc of data.tool_calls) {
                            this.messages.push({ role: 'tool', content: JSON.stringify(tc.result, null, 2), tool_name: tc.name });
                        }
                    }
                    this.messages.push({ role: 'assistant', content: data.response || data.detail || 'No response' });
                    if (data.sources && data.sources.length > 0) {
                        this.currentSources = data.sources;
                    }
                } else {
                    this.messages.push({ role: 'assistant', content: 'Error: request failed' });
                }
            } catch(e) { this.messages.push({ role: 'assistant', content: 'Error: ' + e.message }); }
            finally { this.loading = false; this.scrollToBottom(); }
        },
        scrollToBottom() {
            this.$nextTick(() => {
                const el = document.getElementById('chatMessages');
                if (el) el.scrollTop = el.scrollHeight;
            });
        }
    }
}
</script>
{% endblock %}
